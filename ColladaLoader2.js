// Generated by CoffeeScript 1.3.3
var ColladaAsset, ColladaColorOrTexture, ColladaEffect, ColladaEffectSampler, ColladaEffectSurface, ColladaEffectTechnique, ColladaFile, ColladaFxLink, ColladaGeometry, ColladaImage, ColladaInput, ColladaInstanceGeometry, ColladaInstanceMaterial, ColladaLoader2, ColladaMaterial, ColladaNodeTransform, ColladaSidLink, ColladaSource, ColladaTriangles, ColladaUrlLink, ColladaVertices, ColladaVisualScene, ColladaVisualSceneNode, ThreejsMaterialMap, _colorToHex, _floatsToMatrix4, _floatsToVec3, _strToBools, _strToColor, _strToFloats, _strToInts, _strToStrings;

ColladaUrlLink = (function() {

  function ColladaUrlLink(url) {
    this.url = url.trim().replace(/^#/, "");
    this.object = null;
  }

  return ColladaUrlLink;

})();

ColladaFxLink = (function() {

  function ColladaFxLink(url, scope) {
    this.url = url;
    this.scope = scope;
    this.object = null;
  }

  return ColladaFxLink;

})();

ColladaSidLink = (function() {

  function ColladaSidLink(parentId, url) {
    var arrIndices, arrSyntax, dotSyntax, index, lastSid, parts, _i, _len;
    this.url = url;
    this.object = null;
    this.id = null;
    this.sids = [];
    this.member = null;
    this.indices = null;
    this.dotSyntax = false;
    this.arrSyntax = false;
    parts = url.split("/");
    this.id = parts.shift();
    if (this.id === ".") {
      this.id = parentId;
    }
    while (parts.length > 1) {
      this.sids.push(parts.shift());
    }
    if (parts.length > 0) {
      lastSid = parts[0];
      dotSyntax = lastSid.indexOf(".") >= 0;
      arrSyntax = astSid.indexOf("(") >= 0;
      if (dotSyntax) {
        parts = sid.split(".");
        this.sids.push(parts.shift());
        this.member = parts.shift();
        this.dotSyntax = true;
      } else if (arrSyntax) {
        arrIndices = lastSid.split("(");
        this.sids.push(arrIndices.shift());
        this.indices = [];
        for (_i = 0, _len = arrIndices.length; _i < _len; _i++) {
          index = arrIndices[_i];
          this.indices.push(parseInt(index.replace(/\)/, ""), 10));
        }
        this.arrSyntax = true;
      } else {
        this.sids.push(lastSid);
      }
    }
  }

  return ColladaSidLink;

})();

ColladaAsset = (function() {

  function ColladaAsset() {
    this.unit = 1;
    this.upAxis = null;
  }

  return ColladaAsset;

})();

ColladaVisualScene = (function() {

  function ColladaVisualScene() {
    this.id = null;
    this.children = [];
    this.sidChildren = [];
  }

  return ColladaVisualScene;

})();

ColladaVisualSceneNode = (function() {

  function ColladaVisualSceneNode() {
    this.id = null;
    this.sid = null;
    this.name = null;
    this.type = null;
    this.layer = null;
    this.children = [];
    this.sidChildren = [];
    this.transformations = [];
    this.geometries = [];
  }

  return ColladaVisualSceneNode;

})();

ColladaNodeTransform = (function() {

  function ColladaNodeTransform() {
    this.sid = null;
    this.type = null;
    this.matrix = null;
    this.vector = null;
    this.number = null;
  }

  return ColladaNodeTransform;

})();

ColladaInstanceGeometry = (function() {

  function ColladaInstanceGeometry() {
    this.geometry = null;
    this.materials = [];
  }

  return ColladaInstanceGeometry;

})();

ColladaInstanceMaterial = (function() {

  function ColladaInstanceMaterial() {
    this.sid = null;
    this.symbol = null;
    this.material = null;
    this.name = null;
    this.vertexInputs = {};
    this.params = {};
  }

  return ColladaInstanceMaterial;

})();

ColladaImage = (function() {

  function ColladaImage() {
    this.id = null;
    this.initFrom = null;
  }

  return ColladaImage;

})();

ColladaEffect = (function() {

  function ColladaEffect() {
    this.id = null;
    this.sids = {};
    this.technique = null;
  }

  return ColladaEffect;

})();

ColladaEffectTechnique = (function() {

  function ColladaEffectTechnique() {
    this.sid = null;
    this.sids = {};
    this.fxScope = null;
    this.shading = null;
    this.emission = null;
    this.ambient = null;
    this.diffuse = null;
    this.specular = null;
    this.shininess = null;
    this.reflective = null;
    this.transparent = null;
    this.bump = null;
    this.reflectivity = null;
    this.transparency = null;
    this.index_of_refraction = null;
  }

  return ColladaEffectTechnique;

})();

ColladaEffectSurface = (function() {

  function ColladaEffectSurface() {
    this.sid = null;
    this.fxScope = null;
    this.type = null;
    this.initFrom = null;
    this.format = null;
    this.size = null;
    this.viewportRatio = null;
    this.mipLevels = null;
    this.mipmapGenerate = null;
  }

  return ColladaEffectSurface;

})();

ColladaEffectSampler = (function() {

  function ColladaEffectSampler() {
    this.sid = null;
    this.fxScope = null;
    this.surface = null;
    this.image = null;
    this.wrapS = null;
    this.wrapT = null;
    this.minfilter = null;
    this.magfilter = null;
    this.borderColor = null;
    this.mipmapMaxLevel = null;
    this.mipmapBias = null;
  }

  return ColladaEffectSampler;

})();

ColladaColorOrTexture = (function() {

  function ColladaColorOrTexture() {
    this.color = null;
    this.textureSampler = null;
    this.texcoord = null;
    this.opaque = null;
    this.bumptype = null;
  }

  return ColladaColorOrTexture;

})();

ColladaMaterial = (function() {

  function ColladaMaterial() {
    this.id = null;
    this.name = null;
    this.effect = null;
  }

  return ColladaMaterial;

})();

ColladaGeometry = (function() {

  function ColladaGeometry() {
    this.id = null;
    this.name = null;
    this.sources = {};
    this.vertices = null;
    this.triangles = [];
  }

  return ColladaGeometry;

})();

ColladaSource = (function() {

  function ColladaSource() {
    this.id = null;
    this.name = null;
    this.sourceId = null;
    this.count = null;
    this.stride = null;
    this.data = null;
    this.params = {};
  }

  return ColladaSource;

})();

ColladaVertices = (function() {

  function ColladaVertices() {
    this.id = null;
    this.name = null;
    this.inputs = [];
  }

  return ColladaVertices;

})();

ColladaTriangles = (function() {

  function ColladaTriangles() {
    this.name = null;
    this.count = null;
    this.material = null;
    this.inputs = [];
    this.indices = null;
  }

  return ColladaTriangles;

})();

ColladaInput = (function() {

  function ColladaInput() {
    this.semantic = null;
    this.source = null;
    this.offset = null;
    this.set = null;
  }

  return ColladaInput;

})();

ThreejsMaterialMap = (function() {

  function ThreejsMaterialMap() {
    this.materials = [];
    this.indices = {};
    this.needTangents = false;
  }

  return ThreejsMaterialMap;

})();

ColladaFile = (function() {

  function ColladaFile(loader) {
    var key, value, _ref;
    this.url = null;
    this.baseUrl = null;
    this.loader = loader;
    this.options = {};
    _ref = loader.options;
    for (key in _ref) {
      value = _ref[key];
      this.options[key] = value;
    }
    this._upConversion = null;
    this._log = loader.log;
    this._readyCallback = null;
    this._progressCallback = null;
    this.dae = {};
    this.dae.ids = {};
    this.dae.libEffects = {};
    this.dae.libMaterials = {};
    this.dae.libGeometries = {};
    this.dae.libControllers = {};
    this.dae.libLights = {};
    this.dae.libImages = {};
    this.dae.libVisualScenes = {};
    this.dae.libAnimations = {};
    this.dae.asset = null;
    this.dae.scene = null;
    this.threejs = {};
    this.threejs.scene = null;
    this.threejs.images = [];
    this.threejs.geometries = [];
    this.threejs.materials = [];
  }

  ColladaFile.prototype.setUrl = function(url) {
    var parts, _ref;
    if (url != null) {
      this.url = url;
      parts = url.split("/");
      parts.pop();
      this.baseUrl = ((_ref = parts.length < 1) != null ? _ref : {
        ".": parts.join("/")
      }) + "/";
    } else {
      this.url = "";
      this.baseUrl = "";
    }
  };

  ColladaFile.prototype._reportUnexpectedChild = function(parent, child) {
    this._log("Skipped unknown <" + parent.nodeName + "> child <" + child.nodeName + ">.", ColladaLoader2.messageWarning);
  };

  ColladaFile.prototype._getAttributeAsFloat = function(el, name) {
    var data;
    data = el.getAttribute(name);
    if (data != null) {
      return parseFloat(data);
    } else {
      return null;
    }
  };

  ColladaFile.prototype._getAttributeAsInt = function(el, name) {
    var data;
    data = el.getAttribute(name);
    if (data != null) {
      return parseInt(data, 10);
    } else {
      return null;
    }
  };

  ColladaFile.prototype._addUrlTarget = function(object, lib) {
    var id;
    id = object.id;
    if (!(id != null)) {
      this._log("Object has no ID.", ColladaLoader2.messageError);
      return;
    }
    if (this.dae.ids[id] != null) {
      this._log("There is already an object with ID " + id + ".", ColladaLoader2.messageError);
      return;
    }
    this.dae.ids[id] = object;
    if (lib != null) {
      lib[id] = object;
    }
  };

  ColladaFile.prototype._resolveUrlLink = function(link) {
    link.object = this.dae.ids[link.url];
    if (!(link.object != null)) {
      this._log("Could not resolve URL #" + link.url, ColladaLoader2.messageError);
      return false;
    }
    return true;
  };

  ColladaFile.prototype._addFxTarget = function(object, scope) {
    var sid;
    sid = object.sid;
    if (!(sid != null)) {
      this._log("Cannot add a FX target: object has no SID.", ColladaLoader2.messageError);
      return;
    }
    if (scope.sids[sid] != null) {
      this._log("There is already an FX target with SID " + sid + ".", ColladaLoader2.messageError);
      return;
    }
    object.fxScope = scope;
    scope.sids[sid] = object;
  };

  ColladaFile.prototype._resolveFxLink = function(link) {
    var scope;
    scope = link.scope;
    while (!(link.object != null) && (scope != null)) {
      link.object = scope.sids[link.url];
      scope = scope.fxScope;
    }
    if (!(link.object != null)) {
      this._log("Could not resolve FX parameter #" + link.url, ColladaLoader2.messageError);
      return false;
    }
    return true;
  };

  ColladaFile.prototype._addSidTarget = function(object, parent) {
    if (!(parent.sidChildren != null)) {
      parent.sidChildren = [];
    }
    parent.sidChildren.push(object);
  };

  ColladaFile.prototype._resolveSidLink = function(link) {
    var baseObject, childObject, front, parentObject, queue, sid, sidChild, _i, _j, _len, _len1, _ref, _ref1;
    baseObject = this.dae.ids[link.id];
    if (!(baseObject != null)) {
      this._log("Could not resolve SID #" + link.url + ", missing base ID " + link.id, ColladaLoader2.messageError);
      return false;
    }
    parentObject = baseObject;
    childObject = null;
    _ref = link.sids;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      sid = _ref[_i];
      queue = [parentObject];
      while (queue.length !== 0) {
        front = queue.shift();
        if (front.sid === sid) {
          childObject = front;
          break;
        }
        _ref1 = front.sidChildren;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          sidChild = _ref1[_j];
          queue.push(sidChild);
        }
      }
      if (!(childObject != null)) {
        this._log("Could not resolve SID #" + link.url + ", missing SID part " + sid, ColladaLoader2.messageError);
        return false;
      }
      parentObject = childObject;
    }
    link.object = childObject;
    return true;
  };

  ColladaFile.prototype._getLinkTarget = function(link, type) {
    if (!(link != null)) {
      return null;
    }
    if (!(link.object != null)) {
      if (link instanceof ColladaUrlLink) {
        this._resolveUrlLink(link);
      }
      if (link instanceof ColladaSidLink) {
        this._resolveSidLink(link);
      }
      if (link instanceof ColladaFxLink) {
        this._resolveFxLink(link);
      }
    }
    if ((type != null) && (link.object != null) && !(link.object instanceof type)) {
      this._log("Link " + link.url + " does not link to a " + type.name, ColladaLoader2.messageError);
    }
    return link.object;
  };

  ColladaFile.prototype._parseXml = function(doc) {
    var colladaElement, _ref;
    colladaElement = doc.childNodes[0];
    if ((colladaElement != null ? (_ref = colladaElement.nodeName) != null ? _ref.toUpperCase() : void 0 : void 0) === "COLLADA") {
      this._parseCollada(colladaElement);
    } else {
      this._log("Can not parse document, top level element is not <COLLADA>.", ColladaLoader2.messageError);
    }
  };

  ColladaFile.prototype._parseCollada = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "asset":
            this._parseAsset(child);
            break;
          case "scene":
            this._parseScene(child);
            break;
          case "library_effects":
            this._parseLibEffect(child);
            break;
          case "library_materials":
            this._parseLibMaterial(child);
            break;
          case "library_geometries":
            this._parseLibGeometry(child);
            break;
          case "library_images":
            this._parseLibImage(child);
            break;
          case "library_visual_scenes":
            this._parseLibVisualScene(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseAsset = function(el) {
    var child, _i, _len, _ref;
    if (!this.dae.asset) {
      this.dae.asset = new ColladaAsset();
    }
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "unit":
            this.dae.asset.unit = this._getAttributeAsFloat(child, "meter");
            break;
          case "up_axis":
            this.dae.asset.upAxis = child.textContent.toUpperCase().charAt(0);
            break;
          case "contributor":
          case "created":
          case "modified":
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseScene = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "instance_visual_scene":
            this.dae.scene = new ColladaUrlLink(child.getAttribute("url"));
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseLibVisualScene = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "visual_scene":
            this._parseVisualScene(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseVisualScene = function(el) {
    var child, scene, _i, _len, _ref;
    scene = new ColladaVisualScene;
    scene.id = el.getAttribute("id");
    this._addUrlTarget(scene, this.dae.libVisualScenes);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "node":
            this._parseSceneNode(scene, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseSceneNode = function(parent, el) {
    var child, node, _i, _len, _ref;
    node = new ColladaVisualSceneNode;
    node.id = el.getAttribute("id");
    node.sid = el.getAttribute("sid");
    node.name = el.getAttribute("name");
    node.type = el.getAttribute("type");
    node.layer = el.getAttribute("layer");
    parent.children.push(node);
    if (node.id != null) {
      this._addUrlTarget(node);
    }
    this._addSidTarget(node, parent);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "instance_geometry":
            this._parseInstanceGeometry(node, child);
            break;
          case "matrix":
          case "rotate":
          case "translate":
          case "scale":
            this._parseTransformElement(node, child);
            break;
          case "node":
            this._parseSceneNode(node, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseInstanceGeometry = function(node, el) {
    var child, geometry, _i, _len, _ref;
    geometry = new ColladaInstanceGeometry();
    geometry.geometry = new ColladaUrlLink(el.getAttribute("url"));
    node.geometries.push(geometry);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "bind_material":
            this._parseBindMaterial(geometry, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseBindMaterial = function(geometry, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "technique_common":
            this._parseBindMaterialTechnique(geometry, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseBindMaterialTechnique = function(geometry, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "instance_material":
            this._parseInstanceMaterial(geometry, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseInstanceMaterial = function(geometry, el) {
    var child, inputSemantic, inputSet, material, semantic, target, _i, _len, _ref;
    material = new ColladaInstanceMaterial;
    material.symbol = el.getAttribute("symbol");
    material.material = new ColladaUrlLink(el.getAttribute("target"));
    geometry.materials.push(material);
    this._addSidTarget(material, geometry);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "bind_vertex_input":
            semantic = child.getAttribute("semantic");
            inputSemantic = child.getAttribute("input_semantic");
            inputSet = child.getAttribute("input_set");
            if (inputSet != null) {
              inputSet = parseInt(inputSet);
            }
            material.vertexInputs[semantic] = {
              inputSemantic: inputSemantic,
              inputSet: inputSet
            };
            break;
          case "bind":
            semantic = child.getAttribute("semantic");
            target = new ColladaSidLink(child.getAttribute("target"));
            material.params[semantic] = {
              target: target
            };
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseTransformElement = function(parent, el) {
    var data, transform;
    transform = new ColladaNodeTransform;
    transform.sid = el.getAttribute("sid");
    transform.type = el.nodeName;
    parent.transformations.push(transform);
    this._addSidTarget(transform, parent);
    data = _strToFloats(el.textContent);
    switch (el.nodeName) {
      case "matrix":
        transform.matrix = data;
        break;
      case "rotate":
        transform.number = data[3] * this.TO_RADIANS;
        transform.vector = data;
        break;
      case "translate":
        transform.vector = data;
        break;
      case "scale":
        transform.vector = data;
        break;
      default:
        this._log("Unknown transformation type " + el.nodeName + ".", ColladaLoader2.messageError);
    }
  };

  ColladaFile.prototype._parseLibEffect = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "effect":
            this._parseEffect(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffect = function(el) {
    var child, effect, _i, _len, _ref;
    effect = new ColladaEffect;
    effect.id = el.getAttribute("id");
    this._addUrlTarget(effect, this.dae.libEffects);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "profile_COMMON":
            this._parseEffectProfileCommon(effect, child);
            break;
          case "profile":
            this._log("Skipped non-common effect profile for effect " + effect.id + ".", ColladaLoader2.messageWarning);
            break;
          case "extra":
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectProfileCommon = function(effect, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "newparam":
            this._parseEffectNewparam(effect, child);
            break;
          case "technique":
            this._parseEffectTechnique(effect, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectNewparam = function(scope, el) {
    var child, sid, _i, _len, _ref;
    sid = el.getAttribute("sid");
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "surface":
            this._parseEffectSurface(scope, sid, child);
            break;
          case "sampler2D":
            this._parseEffectSampler(scope, sid, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectSurface = function(scope, sid, el) {
    var child, surface, _i, _len, _ref;
    surface = new ColladaEffectSurface;
    surface.type = el.getAttribute("type");
    surface.sid = sid;
    this._addFxTarget(surface, scope);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "init_from":
            surface.initFrom = new ColladaUrlLink(child.textContent);
            break;
          case "format":
            surface.format = child.textContent;
            break;
          case "size":
            surface.size = _strToFloats(child.textContent);
            break;
          case "viewport_ratio":
            surface.viewportRatio = _strToFloats(child.textContent);
            break;
          case "mip_levels":
            surface.mipLevels = parseInt(child.textContent, 10);
            break;
          case "mipmap_generate":
            surface.mipmapGenerate = child.textContent;
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectSampler = function(scope, sid, el) {
    var child, sampler, _i, _len, _ref;
    sampler = new ColladaEffectSampler;
    sampler.sid = sid;
    this._addFxTarget(sampler, scope);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "source":
            sampler.surface = new ColladaFxLink(child.textContent, scope);
            break;
          case "instance_image":
            sampler.image = new ColladaUrlLink(child.getAttribute("url"));
            break;
          case "wrap_s":
            sampler.wrapS = child.textContent;
            break;
          case "wrap_t":
            sampler.wrapT = child.textContent;
            break;
          case "minfilter":
            sampler.minfilter = child.textContent;
            break;
          case "magfilter":
            sampler.magfilter = child.textContent;
            break;
          case "border_color":
            sampler.borderColor = this._parseColor(child.textContent);
            break;
          case "mipmap_maxlevel":
            sampler.mipmapMaxLevel = parseInt(child.textContent, 10);
            break;
          case "mipmap_bias":
            sampler.mipmapBias = parseFloat(child.textContent);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectTechnique = function(effect, el) {
    var child, technique, _i, _len, _ref;
    technique = new ColladaEffectTechnique;
    technique.sid = el.getAttribute("sid");
    this._addFxTarget(technique, effect);
    effect.technique = technique;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "blinn":
          case "phong":
          case "lambert":
          case "constant":
            this._parseTechniqueParam(technique, "", child);
            break;
          case "extra":
            this._parseTechniqueExtra(technique, "", child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseTechniqueParam = function(technique, profile, el) {
    var child, _i, _len, _ref;
    technique.shading = el.nodeName;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "newparam":
            this._parseEffectNewparam(technique, child);
            break;
          case "emission":
          case "ambient":
          case "diffuse":
          case "specular":
          case "reflective":
            this._parseEffectColorOrTexture(technique, child);
            break;
          case "shininess":
          case "reflectivity":
          case "transparency":
          case "index_of_refraction":
            technique[child.nodeName] = parseFloat(child.childNodes[1].textContent);
            break;
          case "transparent":
            this._parseEffectColorOrTexture(technique, child);
            technique.transparent.opaque = child.getAttribute("opaque");
            break;
          case "bump":
            this._parseEffectColorOrTexture(technique, child);
            technique.bump.bumptype = child.getAttribute("bumptype");
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseTechniqueExtra = function(technique, profile, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "technique":
            profile = child.getAttribute("profile");
            this._parseTechniqueParam(technique, profile, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseEffectColorOrTexture = function(technique, el) {
    var child, colorOrTexture, name, texture, _i, _len, _ref;
    name = el.nodeName;
    colorOrTexture = technique[name];
    if (!(colorOrTexture != null)) {
      colorOrTexture = new ColladaColorOrTexture();
      technique[name] = colorOrTexture;
    }
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "color":
            colorOrTexture.color = _strToColor(child.textContent);
            break;
          case "texture":
            texture = child.getAttribute("texture");
            colorOrTexture.textureSampler = new ColladaFxLink(texture, technique);
            colorOrTexture.texcoord = child.getAttribute("texcoord");
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseLibMaterial = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "material":
            this._parseMaterial(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseMaterial = function(el) {
    var child, material, _i, _len, _ref;
    material = new ColladaMaterial;
    material.id = el.getAttribute("id");
    material.name = el.getAttribute("name");
    this._addUrlTarget(material, this.dae.libMaterials);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "instance_effect":
            material.effect = new ColladaUrlLink(child.getAttribute("url"));
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseLibGeometry = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "geometry":
            this._parseGeometry(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseGeometry = function(el) {
    var child, geometry, _i, _len, _ref;
    geometry = new ColladaGeometry();
    geometry.id = el.getAttribute("id");
    geometry.name = el.getAttribute("name");
    this._addUrlTarget(geometry, this.dae.libGeometries);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "mesh":
            this._parseMesh(geometry, child);
            break;
          case "convex_mesh":
          case "spline":
            this._log("Geometry type " + child.nodeName + " not supported.", ColladaLoader2.messageError);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseMesh = function(geometry, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "source":
            this._parseSource(geometry, child);
            break;
          case "vertices":
            this._parseVertices(geometry, child);
            break;
          case "triangles":
            this._parseTriangles(geometry, child);
            break;
          case "polygons":
          case "polylist":
          case "lines":
          case "linestrips":
          case "trifans":
          case "tristrips":
            this._log("Geometry primitive type " + child.nodeName + " not supported.", ColladaLoader2.messageError);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseSource = function(geometry, el) {
    var child, source, _i, _len, _ref;
    source = new ColladaSource;
    source.id = el.getAttribute("id");
    source.name = el.getAttribute("name");
    this._addUrlTarget(source, geometry.sources);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "bool_array":
            source.sourceId = child.getAttribute("id");
            source.data = _strToBools(child.textContent);
            break;
          case "float_array":
            source.sourceId = child.getAttribute("id");
            source.data = _strToFloats(child.textContent);
            break;
          case "int_array":
            source.sourceId = child.getAttribute("id");
            source.data = _strToInts(child.textContent);
            break;
          case "IDREF_array":
          case "Name_array":
            source.sourceId = child.getAttribute("id");
            source.data = _strToStrings(child.textContent);
            break;
          case "technique_common":
            this._parseSourceTechniqueCommon(source, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseVertices = function(geometry, el) {
    var child, vertices, _i, _len, _ref;
    vertices = new ColladaVertices;
    vertices.id = el.getAttribute("id");
    vertices.name = el.getAttribute("name");
    this._addUrlTarget(vertices, geometry.vertices);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "input":
            vertices.inputs.push(this._parseInput(child));
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseTriangles = function(geometry, el) {
    var child, triangles, _i, _len, _ref;
    triangles = new ColladaTriangles;
    triangles.name = el.getAttribute("name");
    triangles.material = el.getAttribute("material");
    triangles.count = this._getAttributeAsInt(el, "count");
    geometry.triangles.push(triangles);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "input":
            triangles.inputs.push(this._parseInput(child));
            break;
          case "p":
            triangles.indices = _strToInts(child.textContent);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
    return triangles;
  };

  ColladaFile.prototype._parseSourceTechniqueCommon = function(source, el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "accessor":
            this._parseAccessor(source, child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseAccessor = function(source, el) {
    var child, name, sourceId, type, _i, _len, _ref;
    sourceId = el.getAttribute("source");
    source.count = el.getAttribute("count");
    source.stride = this._getAttributeAsInt(el, "stride");
    if (sourceId !== "#" + source.sourceId) {
      this._log("Non-local sources not supported, source data will be empty", ColladaLoader2.messageError);
    }
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "param":
            name = child.getAttribute("name");
            type = child.getAttribute("type");
            source.params[name] = type;
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseInput = function(el) {
    var input;
    input = new ColladaInput;
    input.semantic = el.getAttribute("semantic");
    input.source = new ColladaUrlLink(el.getAttribute("source"));
    input.offset = this._getAttributeAsInt(el, "offset");
    input.set = this._getAttributeAsInt(el, "set");
    return input;
  };

  ColladaFile.prototype._parseLibImage = function(el) {
    var child, _i, _len, _ref;
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "image":
            this._parseImage(child);
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._parseImage = function(el) {
    var child, image, _i, _len, _ref;
    image = new ColladaImage;
    image.id = el.getAttribute("id");
    this._addUrlTarget(image, this.dae.libImages);
    _ref = el.childNodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      child = _ref[_i];
      if (child.nodeType === 1) {
        switch (child.nodeName) {
          case "init_from":
            image.initFrom = child.textContent;
            break;
          default:
            this._reportUnexpectedChild(el, child);
        }
      }
    }
  };

  ColladaFile.prototype._createSceneGraph = function() {
    var daeChild, daeScene, threejsScene, _i, _len, _ref;
    daeScene = this._getLinkTarget(this.dae.scene, ColladaVisualScene);
    if (!(daeScene != null)) {
      return;
    }
    threejsScene = new THREE.Object3D();
    this.threejs.scene = threejsScene;
    _ref = daeScene.children;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      daeChild = _ref[_i];
      this._createSceneGraphNode(daeChild, threejsScene);
    }
    this.scene = threejsScene;
  };

  ColladaFile.prototype._createSceneGraphNode = function(daeNode, threejsParent) {
    var daeChild, daeGeometry, threejsChild, threejsChildren, threejsMesh, threejsNode, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
    threejsChildren = [];
    _ref = daeNode.geometries;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      daeGeometry = _ref[_i];
      threejsMesh = this._createMesh(daeGeometry);
      threejsMesh.name = daeNode.name != null ? daeNode.name : "";
      threejsChildren.push(threejsMesh);
    }
    if (threejsChildren.length > 1) {
      threejsNode = new THREE.Object3D();
      for (_j = 0, _len1 = threejsChildren.length; _j < _len1; _j++) {
        threejsChild = threejsChildren[_j];
        if (threejsChild != null) {
          threejsNode.add(threejsChild);
        }
      }
      threejsParent.add(threejsNode);
    } else if (threejsChildren.length === 1) {
      threejsNode = threejsChildren[0];
      threejsParent.add(threejsNode);
    }
    _ref1 = daeNode.children;
    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
      daeChild = _ref1[_k];
      this._createSceneGraphNode(daeChild, threejsNode);
    }
  };

  ColladaFile.prototype._createMesh = function(daeInstanceGeometry) {
    var material, mesh, symbol, threejsGeometry, threejsMaterial, threejsMaterials, _ref;
    threejsMaterials = this._createMaterials(daeInstanceGeometry);
    threejsGeometry = this._createGeometry(daeInstanceGeometry, threejsMaterials);
    threejsMaterial = null;
    _ref = threejsMaterials.materials;
    for (symbol in _ref) {
      material = _ref[symbol];
      threejsGeometry.materials.push(material);
    }
    if (threejsMaterials.materials.length > 1) {
      threejsMaterial = new THREE.MeshFaceMaterial();
    } else {
      threejsMaterial = threejsMaterials.materials[0];
    }
    mesh = new THREE.Mesh(threejsGeometry, threejsMaterial);
    return mesh;
  };

  ColladaFile.prototype._createGeometry = function(daeInstanceGeometry, materials) {
    var daeGeometry, materialIndex, threejsGeometry, triangles, _i, _len, _ref;
    daeGeometry = this._getLinkTarget(daeInstanceGeometry.geometry, ColladaGeometry);
    if (!(daeGeometry != null)) {
      return null;
    }
    threejsGeometry = new THREE.Geometry();
    _ref = daeGeometry.triangles;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      triangles = _ref[_i];
      materialIndex = materials.indices[triangles.material];
      if (!(materialIndex != null)) {
        this._log("Material symbol " + triangles.material + " has no bound material instance", ColladaLoader2.messageError);
        materialIndex = 0;
      }
      this._addTrianglesToGeometry(daeGeometry, triangles, materialIndex, threejsGeometry);
    }
    threejsGeometry.computeFaceNormals();
    threejsGeometry.computeCentroids();
    if (materials.needtangents) {
      threejsGeometry.computeTangents();
    }
    threejsGeometry.computeBoundingBox();
    return threejsGeometry;
  };

  ColladaFile.prototype._addTrianglesToGeometry = function(daeGeometry, triangles, materialIndex, threejsGeometry) {
    var baseOffset0, baseOffset1, baseOffset2, color, data, dataTriColor, dataTriNormal, dataTriTexcoord, dataVertColor, dataVertNormal, dataVertPos, dataVertTexcoord, face, faceVertexUvs, i, indices, input, inputTriColor, inputTriNormal, inputTriTexcoord, inputTriVertices, inputVertColor, inputVertNormal, inputVertPos, inputVertTexcoord, missingFaces, n0, n1, n2, normal, numExistingFaces, numExistingTexcoordSets, numNewFaces, numNewTexcoordSets, srcTriColor, srcTriNormal, srcTriTexcoord, srcTriVertices, srcVertColor, srcVertNormal, srcVertPos, srcVertTexcoord, t0, t1, t2, texcoord, triangleBaseOffset, triangleStride, v0, v1, v2, vertexStride, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _step, _unused,
      _this = this;
    inputTriVertices = null;
    inputTriNormal = null;
    inputTriColor = null;
    inputTriTexcoord = [];
    _ref = triangles.inputs;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      input = _ref[_i];
      switch (input.semantic) {
        case "VERTEX":
          inputTriVertices = input;
          break;
        case "NORMAL":
          inputTriNormal = input;
          break;
        case "COLOR":
          inputTriColor = input;
          break;
        case "TEXCOORD":
          inputTriTexcoord.push(input);
          break;
        default:
          this._log("Unknown triangles input semantic " + input.semantic + " ignored", ColladaLoader2.messageWarning);
      }
    }
    srcTriVertices = this._getLinkTarget(inputTriVertices.source, ColladaVertices);
    if (!(srcTriVertices != null)) {
      this._log("Geometry " + daeGeometry.id + " has no vertices", ColladaLoader2.messageError);
      return;
    }
    srcTriNormal = this._getLinkTarget(inputTriNormal != null ? inputTriNormal.source : void 0, ColladaSource);
    srcTriColor = this._getLinkTarget(inputTriColor != null ? inputTriColor.source : void 0, ColladaSource);
    srcTriTexcoord = inputTriTexcoord.map(function(x) {
      return _this._getLinkTarget(x != null ? x.source : void 0, ColladaSource);
    });
    inputVertPos = null;
    inputVertNormal = null;
    inputVertColor = null;
    inputVertTexcoord = [];
    _ref1 = srcTriVertices.inputs;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      input = _ref1[_j];
      switch (input.semantic) {
        case "POSITION":
          inputVertPos = input;
          break;
        case "NORMAL":
          inputVertNormal = input;
          break;
        case "COLOR":
          inputVertColor = input;
          break;
        case "TEXCOORD":
          inputVertTexcoord.push(input);
          break;
        default:
          this._log("Unknown vertices input semantic " + input.semantic + " ignored", ColladaLoader2.messageWarning);
      }
    }
    srcVertPos = this._getLinkTarget(inputVertPos.source, ColladaSource);
    if (!(srcVertPos != null)) {
      this._log("Geometry " + daeGeometry.id + " has no vertex positions", ColladaLoader2.messageError);
      return;
    }
    srcVertNormal = this._getLinkTarget(inputVertNormal != null ? inputVertNormal.source : void 0, ColladaSource);
    srcVertColor = this._getLinkTarget(inputVertColor != null ? inputVertColor.source : void 0, ColladaSource);
    srcVertTexcoord = inputVertTexcoord.map(function(x) {
      return _this._getLinkTarget(x != null ? x.source : void 0, ColladaSource);
    });
    dataVertPos = this._createVector3Array(srcVertPos);
    dataVertNormal = this._createVector3Array(srcVertNormal);
    dataTriNormal = this._createVector3Array(srcTriNormal);
    dataVertColor = this._createColorArray(srcVertColor);
    dataTriColor = this._createColorArray(srcTriColor);
    dataVertTexcoord = srcVertTexcoord.map(function(x) {
      return _this._createUVArray(x);
    });
    dataTriTexcoord = srcTriTexcoord.map(function(x) {
      return _this._createUVArray(x);
    });
    threejsGeometry.vertices = dataVertPos;
    numNewTexcoordSets = dataVertTexcoord.length + dataTriTexcoord.length;
    numExistingTexcoordSets = threejsGeometry.faceVertexUvs.length;
    numNewFaces = triangles.count;
    numExistingFaces = threejsGeometry.faces.count;
    _ref2 = threejsGeometry.faceVertexUvs;
    for (i = _k = 0, _len2 = _ref2.length; _k < _len2; i = ++_k) {
      faceVertexUvs = _ref2[i];
      if (i < numNewTexcoordSets) {
        missingFaces = faceVertexUvs.length - threejsGeometry.faces.length;
        this._addEmptyUVs(faceVertexUvs, missingFaces);
      } else {
        missingFaces = faceVertexUvs.length - threejsGeometry.faces.length + numNewFaces;
        this._addEmptyUVs(faceVertexUvs, missingFaces);
      }
    }
    while (threejsGeometry.faceVertexUvs.length < numNewTexcoordSets) {
      faceVertexUvs = [];
      this._addEmptyUVs(faceVertexUvs, numExistingFaces);
      threejsGeometry.faceVertexUvs.push(faceVertexUvs);
    }
    indices = triangles.indices;
    triangleStride = indices.length / triangles.count;
    vertexStride = triangleStride / 3;
    _ref3 = triangles.indices;
    for (triangleBaseOffset = _l = 0, _len3 = _ref3.length, _step = triangleStride; _l < _len3; triangleBaseOffset = _l += _step) {
      _unused = _ref3[triangleBaseOffset];
      baseOffset0 = triangleBaseOffset + 0 * vertexStride;
      baseOffset1 = triangleBaseOffset + 1 * vertexStride;
      baseOffset2 = triangleBaseOffset + 2 * vertexStride;
      v0 = indices[baseOffset0 + inputTriVertices.offset];
      v1 = indices[baseOffset1 + inputTriVertices.offset];
      v2 = indices[baseOffset2 + inputTriVertices.offset];
      if (dataVertNormal != null) {
        normal = [dataVertNormal[v0], dataVertNormal[v1], dataVertNormal[v2]];
      } else if (dataTriNormal != null) {
        n0 = indices[baseOffset0 + inputTriNormal.offset];
        n1 = indices[baseOffset1 + inputTriNormal.offset];
        n2 = indices[baseOffset2 + inputTriNormal.offset];
        normal = [dataTriNormal[n0], dataTriNormal[n1], dataTriNormal[n2]];
      } else {
        normal = null;
      }
      if (dataVertColor != null) {
        color = [dataVertColor[v0], dataVertColor[v1], dataVertColor[v2]];
      } else if (dataTriColor != null) {
        n0 = indices[baseOffset0 + inputTriColor.offset];
        n1 = indices[baseOffset1 + inputTriColor.offset];
        n2 = indices[baseOffset2 + inputTriColor.offset];
        color = [dataTriColor[n0], dataTriColor[n1], dataTriColor[n2]];
      } else {
        color = null;
      }
      face = new THREE.Face3(v0, v1, v2, normal, color);
      if (materialIndex != null) {
        face.materialIndex = materialIndex;
      }
      threejsGeometry.faces.push(face);
      for (i = _m = 0, _len4 = dataVertTexcoord.length; _m < _len4; i = ++_m) {
        data = dataVertTexcoord[i];
        if (!(data != null)) {
          geometry.faceVertexUvs[i].push([new THREE.UV(0, 0), new THREE.UV(0, 0), new THREE.UV(0, 0)]);
        } else {
          texcoord = [data[v0], data[v1], data[v2]];
          geometry.faceVertexUvs[i].push(texcoord);
        }
      }
      for (i = _n = 0, _len5 = dataTriTexcoord.length; _n < _len5; i = ++_n) {
        data = dataTriTexcoord[i];
        if (!(data != null)) {
          geometry.faceVertexUvs[i].push([new THREE.UV(0, 0), new THREE.UV(0, 0), new THREE.UV(0, 0)]);
        } else {
          t0 = indices[baseOffset0 + inputTriTexcoord[i].offset];
          t1 = indices[baseOffset1 + inputTriTexcoord[i].offset];
          t2 = indices[baseOffset2 + inputTriTexcoord[i].offset];
          texcoord = [data[t0], data[t1], data[t2]];
          threejsGeometry.faceVertexUvs[i].push(texcoord);
        }
      }
    }
  };

  ColladaFile.prototype._addEmptyUVs = function(faceVertexUvs, count) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
      faceVertexUvs.push(new THREE.UV(0, 0));
    }
  };

  ColladaFile.prototype._createVector3Array = function(source) {
    var data, i, srcData, _i, _ref;
    if (!(source != null)) {
      return null;
    }
    if (source.stride !== 3) {
      this._log("Vector source data does not contain 3D vectors", ColladaLoader2.messageError);
      return null;
    }
    data = [];
    srcData = source.data;
    for (i = _i = 0, _ref = srcData.length - 1; _i <= _ref; i = _i += 3) {
      data.push(new THREE.Vector3(srcData[i], srcData[i + 1], srcData[i + 2]));
    }
    return data;
  };

  ColladaFile.prototype._createColorArray = function(source) {
    var data, i, srcData, _i, _ref, _ref1;
    if (!(source != null)) {
      return null;
    }
    if (source.stride < 3) {
      this._log("Color source data does not contain 3+D vectors", ColladaLoader2.messageError);
      return null;
    }
    data = [];
    srcData = source.data;
    for (i = _i = 0, _ref = srcData.length - 1, _ref1 = source.stride; 0 <= _ref ? _i <= _ref : _i >= _ref; i = _i += _ref1) {
      data.push(new THREE.Color().setRGB(srcData[i], srcData[i + 1], srcData[i + 2]));
    }
    return data;
  };

  ColladaFile.prototype._createUVArray = function(source) {
    var data, i, srcData, _i, _ref, _ref1;
    if (!(source != null)) {
      return null;
    }
    if (source.stride < 2) {
      this._log("UV source data does not contain 2+D vectors", ColladaLoader2.messageError);
      return null;
    }
    data = [];
    srcData = source.data;
    for (i = _i = 0, _ref = srcData.length - 1, _ref1 = source.stride; 0 <= _ref ? _i <= _ref : _i >= _ref; i = _i += _ref1) {
      data.push(new THREE.UV(srcData[i], 1.0 - srcData[i + 1]));
    }
    return data;
  };

  ColladaFile.prototype._createMaterials = function(daeInstanceGeometry) {
    var daeInstanceMaterial, numMaterials, result, symbol, threejsMaterial, _i, _len, _ref;
    result = new ThreejsMaterialMap;
    numMaterials = 0;
    _ref = daeInstanceGeometry.materials;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      daeInstanceMaterial = _ref[_i];
      symbol = daeInstanceMaterial.symbol;
      if (!(symbol != null)) {
        this._log("Material instance has no symbol, material skipped.", ColladaLoader2.messageError);
        continue;
      }
      if (result.indices[symbol] != null) {
        this._log("Geometry instance tried to map material symbol " + symbol + " multiple times", ColladaLoader2.messageError);
        continue;
      }
      threejsMaterial = this._createMaterial(daeInstanceMaterial);
      if (threejsMaterial instanceof THREE.ShaderMaterial) {
        result.needtangents = true;
      }
      this.threejs.materials.push(threejsMaterial);
      result.materials.push(threejsMaterial);
      result.indices[symbol] = numMaterials++;
    }
    return result;
  };

  ColladaFile.prototype._createMaterial = function(daeInstanceMaterial) {
    var daeEffect, daeMaterial;
    daeMaterial = this._getLinkTarget(daeInstanceMaterial.material, ColladaMaterial);
    if (!(daeMaterial != null)) {
      return this._createDefaultMaterial;
    }
    daeEffect = this._getLinkTarget(daeMaterial.effect, ColladaEffect);
    if (!(daeEffect != null)) {
      return this._createDefaultMaterial;
    }
    if (daeEffect.technique.bump != null) {
      return this._createShaderMaterial(daeEffect);
    } else {
      return this._createBuiltInMaterial(daeEffect);
    }
  };

  ColladaFile.prototype._createShaderMaterial = function(daeEffect) {
    var materialNormalMap, shader, technique, textureDiffuse, textureLight, textureNormal, textureSpecular, uniforms, _ref, _ref1, _ref2;
    technique = daeEffect.technique;
    shader = THREE.ShaderUtils.lib["normal"];
    uniforms = THREE.UniformsUtils.clone(shader.uniforms);
    textureNormal = this._loadThreejsTexture(technique.bump);
    if (textureNormal != null) {
      uniforms["tNormal"].texture = textureNormal;
      uniforms["uNormalScale"].value = 0.85;
    }
    textureDiffuse = this._loadThreejsTexture(technique.diffuse);
    if (textureDiffuse != null) {
      uniforms["tDiffuse"].texture = textureDiffuse;
      uniforms["enableDiffuse"].value = true;
    } else {
      uniforms["enableDiffuse"].value = false;
    }
    textureSpecular = this._loadThreejsTexture(technique.specular);
    if (textureSpecular != null) {
      uniforms["tSpecular"].texture = textureSpecular;
      uniforms["enableSpecular"].value = true;
    } else {
      uniforms["enableSpecular"].value = false;
    }
    textureLight = this._loadThreejsTexture(technique.emission);
    if (textureLight != null) {
      uniforms["tAO"].texture = textureLight;
      uniforms["enableAO"].value = true;
    } else {
      uniforms["enableAO"].value = false;
    }
    if (((_ref = technique.diffuse) != null ? _ref.color : void 0) != null) {
      uniforms["uDiffuseColor"].value.setHex(_colorToHex(technique.diffuse.color));
    }
    if (((_ref1 = technique.specular) != null ? _ref1.color : void 0) != null) {
      uniforms["uSpecularColor"].value.setHex(_colorToHex(technique.specular.color));
    }
    if (((_ref2 = technique.ambient) != null ? _ref2.color : void 0) != null) {
      uniforms["uAmbientColor"].value.setHex(_colorToHex(technique.ambient.color));
    }
    if (technique.shnininess != null) {
      uniforms["uShininess"].value = technique.shininess;
    }
    if (technique.transparency != null) {
      uniforms["uOpacity"].value = this._getOpacity(daeEffect);
    }
    materialNormalMap = new THREE.ShaderMaterial({
      fragmentShader: shader.fragmentShader,
      vertexShader: shader.vertexShader,
      uniforms: uniforms,
      lights: true
    });
    return materialNormalMap;
  };

  ColladaFile.prototype._getOpacity = function(daeEffect) {
    var opacityMode, technique, transparency, transparent, transparentA, _ref;
    technique = daeEffect.technique;
    transparent = technique.transparent;
    opacityMode = transparent != null ? transparent.opaque : void 0;
    if ((opacityMode != null) && opacityMode !== "A_ONE") {
      this._log("Opacity mode " + opacityMode + " not supported, transparency will be broken", ColladaLoader2.messageWarning);
    }
    if ((transparent != null ? transparent.textureSampler : void 0) != null) {
      this._log("Separate transparency texture not supported, transparency will be broken", ColladaLoader2.messageWarning);
    }
    transparentA = (transparent != null ? (_ref = transparent.color) != null ? _ref[3] : void 0 : void 0) || 1;
    transparency = technique.transparency || 1;
    return transparentA * transparency;
  };

  ColladaFile.prototype._createBuiltInMaterial = function(daeEffect) {
    var opacity, params, technique;
    technique = daeEffect.technique;
    params = {};
    this._setThreejsMaterialParam(params, technique.diffuse, "diffuse", "map", false);
    this._setThreejsMaterialParam(params, technique.emission, "emissive", "map", false);
    this._setThreejsMaterialParam(params, technique.ambient, "ambient", "map", false);
    this._setThreejsMaterialParam(params, technique.specular, "specular", "map", false);
    if (technique.shininess != null) {
      params.shininess = technique.shininess;
    }
    if (technique.reflectivity != null) {
      params.reflectivity = technique.reflectivity;
    }
    opacity = this._getOpacity(daeEffect);
    if (opacity < 1.0) {
      params.transparent = true;
      params.opacity = opacity;
    }
    params.shading = THREE.SmoothShading;
    params.perPixel = true;
    switch (technique.shading) {
      case "blinn":
      case "phong":
        params.color = params.diffuse;
        return new THREE.MeshPhongMaterial(params);
      case "lambert":
        params.color = params.diffuse;
        return new THREE.MeshLambertMaterial(params);
      case "constant":
        params.color = params.emission;
        return new THREE.MeshBasicMaterial(params);
      default:
        return this._createDefaultMaterial;
    }
  };

  ColladaFile.prototype._createDefaultMaterial = function() {
    return new THREE.MeshLambertMaterial({
      color: 0xdddddd,
      shading: THREE.FlatShading
    });
  };

  ColladaFile.prototype._setThreejsMaterialParam = function(params, colorOrTexture, nameColor, nameTexture, replace) {
    var threejsTexture;
    if (!(colorOrTexture != null)) {
      return;
    }
    if ((colorOrTexture.color != null) && (nameColor != null)) {
      if (!replace && (params[nameColor] != null)) {
        return;
      }
      params[nameColor] = _colorToHex(colorOrTexture.color);
    } else if ((colorOrTexture.textureSampler != null) && (nameTexture != null)) {
      if (!replace && (params[nameTexture] != null)) {
        return;
      }
      threejsTexture = this._loadThreejsTexture(colorOrTexture);
      if (threejsTexture != null) {
        params[nameTexture] = threejsTexture;
      }
    }
  };

  ColladaFile.prototype._loadThreejsTexture = function(colorOrTexture) {
    var imageURL, textureImage, textureSampler, textureSurface;
    if (!(colorOrTexture.textureSampler != null)) {
      return null;
    }
    textureSampler = this._getLinkTarget(colorOrTexture.textureSampler, ColladaEffectSampler);
    if (!(textureSampler != null)) {
      return null;
    }
    textureImage = null;
    if (textureSampler.image != null) {
      textureImage = this._getLinkTarget(textureSampler.image, ColladaImage);
    } else if (textureSampler.surface != null) {
      textureSurface = this._getLinkTarget(textureSampler.surface, ColladaEffectSurface);
      textureImage = this._getLinkTarget(textureSurface.initFrom, ColladaImage);
    }
    if (!(textureImage != null)) {
      return null;
    }
    imageURL = this.baseUrl + textureImage.initFrom;
    return this.loader._loadTextureFromURL(imageURL);
  };

  return ColladaFile;

})();

ColladaLoader2 = (function() {

  ColladaLoader2.messageTrace = 0;

  ColladaLoader2.messageInfo = 1;

  ColladaLoader2.messageWarning = 2;

  ColladaLoader2.messageError = 3;

  ColladaLoader2.messageTypes = ["TRACE", "INFO", "WARNING", "ERROR"];

  ColladaLoader2.imageLoadNormal = 1;

  ColladaLoader2.imageLoadSimple = 2;

  ColladaLoader2.imageLoadCacheOnly = 3;

  function ColladaLoader2() {
    this.log = this.logConsole;
    this.TO_RADIANS = Math.PI / 180.0;
    this._imageCache = {};
    this.options = {
      imageLoadType: ColladaLoader2.imageLoadNormal
    };
  }

  ColladaLoader2.logConsole = function(msg, type) {
    console.log("ColladaLoader2 " + ColladaLoader2.messageTypes[type] + ": " + msg);
  };

  ColladaLoader2.prototype.setLog = function(logCallback) {
    this.log = logCallback || this.logConsole;
  };

  ColladaLoader2.prototype.addChachedTextures = function(textures) {
    var key, value;
    for (key in textures) {
      value = textures[key];
      this._imageCache[key] = value;
    }
  };

  ColladaLoader2.prototype.load = function(url, readyCallback, progressCallback) {
    var length, req, _ref,
      _this = this;
    length = 0;
    if ((_ref = document.implementation) != null ? _ref.createDocument : void 0) {
      req = new XMLHttpRequest();
      if (typeof req.overrideMimeType === "function") {
        req.overrideMimeType("text/xml");
      }
      req.onreadystatechange = function() {
        if (req.readyState === 4) {
          if (req.status === 0 || req.status === 200) {
            if (req.responseXML) {
              return _this.parse(req.responseXML, readyCallback, url);
            } else {
              return _this.log("Empty or non-existing file " + url + ".", ColladaLoader2.messageError);
            }
          }
        } else if (req.readyState === 3) {
          if (progressCallback) {
            if (length === 0) {
              length = req.getResponseHeader("Content-Length");
            }
            return progressCallback({
              total: length,
              loaded: req.responseText.length
            });
          }
        }
      };
      req.open("GET", url, true);
      req.send(null);
    } else {
      this.log("Don't know how to parse XML!", ColladaLoader2.messageError);
    }
  };

  ColladaLoader2.prototype.parse = function(doc, readyCallback, url) {
    var file;
    file = new ColladaFile(this);
    file.setUrl(url);
    file._readyCallback = readyCallback;
    file._parseXml(doc);
    file._createSceneGraph();
    if (file._readyCallback) {
      file._readyCallback(file);
    }
    return file;
  };

  ColladaLoader2.prototype._loadTextureFromURL = function(imageURL) {
    var cachedURLBase, image, imageURLBase, key, texture, value, _ref, _ref1;
    texture = this._imageCache[imageURL];
    if (texture != null) {
      return texture;
    }
    switch (this.options.imageLoadType) {
      case ColladaLoader2.imageLoadNormal:
        texture = THREE.ImageUtils.loadTexture(imageURL);
        break;
      case ColladaLoader2.imageLoadSimple:
        image = document.createElement("img");
        texture = new THREE.Texture(image);
        image.onload = function() {
          return texture.needsUpdate = true;
        };
        image.src = imageURL;
        break;
      case ColladaLoader2.imageLoadCache:
        imageURLBase = this._removeSameDirectoryPath(imageURL);
        _ref = this._imageCache;
        for (key in _ref) {
          value = _ref[key];
          cachedURLBase = this._removeSameDirectoryPath(key);
          if (imageURLBase.indexOf(cachedURLBase) >= 0) {
            texture = value;
            break;
          }
        }
        imageURLBase = this._removeSameDirectoryPath(this._removeFileExtension(imageURL));
        if (!(texture != null)) {
          _ref1 = this._imageCache;
          for (key in _ref1) {
            value = _ref1[key];
            cachedURLBase = this._removeSameDirectoryPath(this._removeFileExtension(key));
            if (imageURLBase.indexOf(cachedURLBase) >= 0) {
              texture = value;
              break;
            }
          }
        }
        break;
      default:
        this.log("Unknown image load type, texture will not be loaded.", ColladaLoader2.messageError);
    }
    if (texture != null) {
      this._imageCache[imageURL] = texture;
    } else {
      this.log("Texture " + imageURL + " could not be loaded, texture will be ignored.", ColladaLoader2.messageError);
    }
    return texture;
  };

  ColladaLoader2.prototype._removeFileExtension = function(filePath) {
    return filePath.substr(0, filePath.lastIndexOf(".")) || filePath;
  };

  ColladaLoader2.prototype._removeSameDirectoryPath = function(filePath) {
    return filePath.replace(/^.\//, "");
  };

  return ColladaLoader2;

})();

_strToStrings = function(str) {
  var trimmed;
  if (str.length > 0) {
    trimmed = str.trim();
    return trimmed.split(/\s+/);
  } else {
    return [];
  }
};

_strToFloats = function(str) {
  var data, i, string, strings, _i, _len;
  strings = _strToStrings(str);
  data = new Float32Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = parseFloat(string);
  }
  return data;
};

_strToInts = function(str) {
  var data, i, string, strings, _i, _len;
  strings = _strToStrings(str);
  data = new Int32Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = parseInt(string, 10);
  }
  return data;
};

_strToBools = function(str) {
  var data, i, string, strings, _i, _len, _ref;
  strings = _strToStrings(str);
  data = new Uint8Array(strings.length);
  for (i = _i = 0, _len = strings.length; _i < _len; i = ++_i) {
    string = strings[i];
    data[i] = (_ref = string === "true" || string === "1") != null ? _ref : {
      1: 0
    };
  }
  return data;
};

_strToColor = function(str) {
  var rgba;
  rgba = _strToFloats(str);
  if (rgba.length === 4) {
    return rgba;
  } else {
    return null;
  }
};

_colorToHex = function(rgba) {
  if (rgba != null) {
    return Math.floor(rgba[0] * 255) << 16 ^ Math.floor(rgba[1] * 255) << 8 ^ Math.floor(rgba[2] * 255);
  } else {
    return null;
  }
};

_floatsToMatrix4 = function(data) {
  return new THREE.Matrix4(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15]);
};

_floatsToVec3 = function(data) {
  return new THREE.Vector3(data[0], data[1], data[2]);
};

if (typeof window !== "undefined" && window !== null) {
  window.ColladaLoader2 = ColladaLoader2;
} else if (typeof module !== "undefined" && module !== null) {
  module["export"] = ColladaLoader2;
}
